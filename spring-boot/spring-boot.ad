= Spring Boot Testing

== @SpringBootTest

[source,java]
@BootstrapWith(SpringBootTestContextBootstrapper.class)
@ExtendWith(SpringExtension.class)
public @interface SpringBootTest {

=== SpringBootTestContextBootstrapper

- Uses `SpringBootContextLoader` as the default context loader.
- Automatically searches for a `@SpringBootConfiguration` when required.
- Allows custom Environment getProperties(Class) to be defined.
- Provides support for different webEnvironment modes.

=== SpringBootContextLoader

The loader supports both standard `MergedContextConfiguration` as well as `WebMergedContextConfiguration`.
If `WebMergedContextConfiguration` is used the context will either use a mock servlet environment,
or start the full embedded web server.

If `@ActiveProfiles` are provided in the test class they will be used to create the application context.

=== AnnotatedClassFinder

Sucht nach SpringBootConfiguration

Basis: Package der Testklasse, dann recursiv parent package

[source, java]
new AnnotatedClassFinder(SpringBootConfiguration.class)
				.findFromClass(mergedConfig.getTestClass())


=== ConfigurationClassPostProcessor

BeanFactoryPostProcessor used for bootstrapping processing of @Configuration classes.
Registered by default when using `<context:annotation-config/>` or `<context:component-scan/>`.

WARNING: wo wird dieser in Spring Boot aktiviert?

?? es wird nach Kandidat mit Marker gesucht, geschieht innerhalb von refresh ??

-> abbilden ohne Spring-Boot

=== ClassPathScanningCandidateComponentProvider

hier ist Logik von Config Slicing

useDefaultFilters - whether to register the default filters for the @Component, @Repository, @Service, and @Controller stereotype annotations

[source, java]
----
new ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters, Environment environment)
----

org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.scanCandidateComponents

includeFilters + excludeFilters, die vermutlich von @WebMvcTest und anderem kommen

`isCandidateComponent()`

1. must not be in exludeFilters
1. must be in inlcudeFilters (default `@Component, @Named, @ManagedBean`)
1. `isConditionMatch()`, see `org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchOutcome`

innerhalb von
org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext

WARNING: You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far. For this reason, we recommend using only `@ConditionalOnBean` and `@ConditionalOnMissingBean` annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added). https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html#boot-features-bean-conditions[Spring Boot - Bean Conditions]

=== @WebMvcTest
[source, java]
@TypeExcludeFilters(WebMvcTypeExcludeFilter.class)

[source, java]
----
WebMvcTypeExcludeFilter {
    DEFAULT_INCLUDES =
    @ControllerAdvice
    @JsonComponent
    WebMvcConfigurer
    javax.servlet.Filter
    FilterRegistrationBean
    DelegatingFilterProxyRegistrationBean
    HandlerMethodArgumentResolver
    HttpMessageConverter
    ErrorAttributes
    Converter
    GenericConverter

    protected Set<Class<?>> getDefaultIncludes() {
        if (this.annotation.secure()) {
            if (ObjectUtils.isEmpty(this.annotation.controllers())) {
                return DEFAULT_INCLUDES_SECURITY_CONFIGURER_AND_CONTROLLER;
            }
            return DEFAULT_INCLUDES_AND_SECURITY_CONFIGURER;
        }
        if (ObjectUtils.isEmpty(this.annotation.controllers())) {
            // DEFAULT_INCLUDES + @Controller
            return DEFAULT_INCLUDES_AND_CONTROLLER;
        }
        return DEFAULT_INCLUDES;
    }
}
----

[source,java]
----
protected boolean defaultInclude(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
    for (Class<?> include : getDefaultIncludes()) {
        if (isTypeOrAnnotated(metadataReader, metadataReaderFactory, include)) {
            return true;
        }
    }
    // !!! warum ist componentInclude nur aktiv, falls default include aktiv?
    for (Class<?> component : getComponentIncludes()) {
        if (isTypeOrAnnotated(metadataReader, metadataReaderFactory, component)) {
            return true;
        }
    }
    return false;
}
----

ControllerAdvice in include enthalten

Entscheidung in org.springframework.boot.context.TypeExcludeFilter.match



[plantuml]
----
TypeExcludeFilter <|-- AnnotationCustomizableTypeExcludeFilter
AnnotationCustomizableTypeExcludeFilter <|-- WebMvcTypeExcludeFilter
class AnnotationCustomizableTypeExcludeFilter {
    + match()
    ..
    checks if class is included and not excluded
}
----


=== ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider

sucht nach `@Component`, `@Repository`, `@Service`, or `@Controller`

org.springframework.context.annotation.ComponentScanAnnotationParser.parse

class = com.unitedinternet.id.op.frontend.base.TestApplication
componentScanAttributes

[source,groovy]
basePackages = (basePackages + basePackageClasses) ?: ClassUtils.getPackageName(declaringClass)

Breakpoints: org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan

Interessant Logs mittels
org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider und ClassPathBeanDefinitionScanner on DEBUG

=== SpringFactoriesLoader

Lädt `META-INF/spring.factories`

[source, java]
SpringFactoriesLoader.loadFactories(SpringFactoryClass.class, null)

kann Klasse oder Interface sein, values müssen dem key assigned werden können
[source, properties]
org.devll.samples.springboot.SpringBootTestTests$SpringFactoryClass=org.devll.samples.springboot.SpringBootTestTests.SpringFactoryObject

=== @AutoConfigureMockMvc

Activates especially `MockMvcAutoConfiguration`.

[source,properties]
.spring.factories
----
# AutoConfigureMockMvc auto-configuration imports
org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc=\
org.springframework.boot.test.autoconfigure.web.servlet.MockMvcAutoConfiguration,\
org.springframework.boot.test.autoconfigure.web.servlet.MockMvcSecurityAutoConfiguration,\
org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebClientAutoConfiguration,\
org.springframework.boot.test.autoconfigure.web.servlet.MockMvcWebDriverAutoConfiguration
----

`MockMvcAutoConfiguration` modifies the root web application context (searches in parent if child is not already one).

In combination with @ContextHierarchy only last child will be enhanced:

[quote, Phillip Webb 18.04.17 22:47, Support @SpringBootTest with @ContextHierarchy]
Update SpringBootTestContextBootstrapper to detect `@ContextHierarchy` annotations so that only the last child creates a `WebApplicationContext`.

=== @ContextHiearchy

Handling done in

org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration()

=== Context Caching with ContextHiearchy

Advantage only for @ConditionalOnMissingBean

AutoConfiguration class itself is duplicated i.e.

MockMvcSecurityAutoConfiguration

TIP: why!!!, how is this created?

=== Context Caching

Done via `org.springframework.test.context.CacheAwareContextLoaderDelegate`

=== Component Indexer

in `org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents`

[source,java]
.ClassPathScanningCandidateComponentProvider.java
----
public Set<BeanDefinition> findCandidateComponents(String basePackage) {
    if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
        return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
    }
    else {
        return scanCandidateComponents(basePackage);
    }
}
----

